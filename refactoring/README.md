# 책 소개

**리팩터링, 마틴 파울러**

<img width="400" src="./img.jpg" alt="리팩터링">

## 목차

- [1. 리팩터링 첫 번째 예시](#1-리팩터링-첫-번째-예시)
- [2. 리팩터링 원칙](#2-리팩터링-원칙)

## 1. 리팩터링 첫 번째 예시

p.26 예시 프로그램을 본 수감

설계가 나쁜 시스템은 수정하기 어렵다. 원하는 동작을 수행하도록 하기위해 수정해야 할 부분을 찾고, 기존 코드와 잘 맞물려 작동하게 할 방법을 강구하기가 어렵기 때문이다. 무엇을 수정할지 찾기 어렵다면 실수를 저질러서 버그가 생길 가능성도 높아진다.

수백 줄짜리 코드를 수정할 때면 먼저 프로그램의 작동 방식을 더 쉽게 파악할 수 있도록 코드를 여러 함수와 프로그램 요소로 재구성한다. 프로그램의 구조가 빈약하다면 대체로 구조부터 바로잡은 뒤에 기능을 수정하는 편이 작업하기가 훨씬 수월하다.

**프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.**

## 2. 리팩터링 원칙

### 2.1 리팩터링정의

- **소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법**
- 명사 - 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
- 동사 - 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다
- 지금껏 수많은 사람이 코드를 정리하는 작업을 모두 ‘리팩터링’이라고 표현하고 있는데, 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다
- 누군가 “리팩터링하다가 코드가 깨져서 며칠이나 고생했다”라고 한다면, 십중팔구 리팩터링한 것이 아니다
- 한 번에 바꿀 수 있는 작업을 수많은 단계로 잘게 나눠서 작업하는 모습을 처음 접하면 리팩터링하는 것이 오히려 비효율적이라고 생각하기 쉽다. 하지만 이렇게 잘게 나눔으로써 오히려 작업을 더 빨리 처리할 수 있다
- 무엇보다 디버깅하는 데 시간을 뺏기지 않기 때문이다
- 리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다. 사용자의 관점에서는 달라지는 점이 없어야 한다
- 리팩터링은 성능 최적화와 비슷하다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다. 단지 목적이 다를 뿐이다. 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 반면 성능 최적화는 오로지 속도 개선에만 신경 쓴다. 그래서 목표 성능에 반드시 도달해야 한다면 코드는 다루기에 더 어렵게 바뀔 수도 있음을 각오해야 한다

### 2.2 두 개의 모자

- 소프트웨어를 개발할 때 목적이 ‘기능 추가’냐, 아니면 ‘리팩터링’이냐를 명확히 구분해 작업한다
- 켄트 벡은 이를 두 개의 모자에 비유했다.
- 기능을 추가할 때는 ‘기능 추가’모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다
- 리팩터링할 때는 ‘리팩터링’ 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다

### 2.3 리팩토링하는 이유

1. 소프트웨어 설계가 좋아진다

   - 리팩터링하지 않으면 소프트웨어 내부 설계(아키텍처)가 썩기 쉽다
   - 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. 그렇다면 코드만 봐서는 설계를 파악하기 어려워진다
   - 코드 구조가 무너지기 시작하면 악효과가 누적된다
   - 같은 일을 하더라도 설계까 나쁘면 코드가 길어지기 십상이다
   - 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있으며, 이는 바람직한 설계의 핵심이다

2. 소프트웨어를 이해하기 쉬워진다

   - 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야 한다
   - 프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일이다
   - 리팩터링은 코드가 더 잘 읽히게 도와준다
   - 단지 다른 사람을 배려하기 위해서가 아니다. 사실 그 다른 사람이 바로 나 자신일 때가 많다
   - 기억할 필요가 있는 것은 최대한 코드에 담으려고 한다(코드 자체만 보고 파악할 수 있도록 만드는 것이 제일 좋다)

3. 버그를 쉽게 찾을 수 있따

   - 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다
   - 리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다

4. 프로그래밍 속도를 높일 수 있다

   - 한 시스템을 오래 개발 중인 개발자들과 얘기하다 보면 초기에는 진척이 빨랐지만 현재는 새 기능을 하나 추가하는데 훨씬 오래 걸린다는 말을 많이 한다
   - 새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다는 것이다
   - 설령 프로그램 요구사항이 바뀌더라도 설계를 지속해서 개선할 수 있다
   - 그래서 빠른 개발이라는 숭고한 목표를 달성하려면 리팩터링이 반드시 필요하다

### 2.4 언제 리팩토링 해야 하나?

1. 프로젝트 시작단계

   - 좋은 디자인 패턴으로 코드를 깔끔하게 작성
   - 기능 구현을 위한 코드를 작성
   - 테스트 코드를 작성 (테스트 코드를 동작하게 하기 위한 리팩토링)
   - **3의 법칙: 비슷한 일을 세 번쨰 하게 되면 리팩토링한다**
   - 코드를 이해하기 쉽게 만들기 > 좋은 문서화
   - 기능을 쉽게 추가하게 만들기 > 재사용성, 모듈성을 높일 수 있음

2. 프로젝트 유지보수 단계

   - 버그름 검증할 수 있는 테스트 코드
   - 코드를 이해하기 쉽게, 변경하기 쉽게 변경 (리팩토링)

3. 오래된(레거시) 프로젝트

   - (버그 수정 및 기능추가시에만) 수정이 필요한 모듈/코드 한정적으로 테스트 추가
   - 리팩토링을 통해 코드 수정 또는 기능을 추가
   - 때로는 새로운 코드를 작성하는 것이 빠를 수 있으므로 우선순위에 따라 전략을 다르게 가져가야 한다

### 2.5 리팩토링 시 고려할 문제

- “무결점 클린코드, 완벽한 설계는 존재하지 않는다”를 인정해야 한다
- 상황에 맞게 좋은 디자인 패턴으로 코드를 깔끔하게 작성하면 된다
- 먼저 기능 구현을 위한 코드를 작성한 이후 테스트 코드를 작성하며 리팩토링을 해나간다.

### 2.6 리팩터링, 아키텍처, 애그니

- 애**그니**: **Y**ou **A**in’t **G**onna **N**eed **I**t
- 당장 필요하지 않는 기능에 집착해서 코드를 지나치게 복잡하게 만들 필요가 없다
- 사용하지 않는 기능을 우선적으로 만들 필요가 없다
- 지나치게 미래지향적인 코드를 작성할 필요가 없다

### 2.7 리팩터링과 소프트웨어 개발 프로세스

- 자가 테스트 코드와 리팩터링을 묶어서 테스트 주도 개발(TDD)이라 한다
- 리팩터링의 첫 번째 토대는 자가 테스트 코드다
- 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할 수 있어야 한다
- 지속적 통합을 적용하면 팀원 각자가 수행한 리팩터링 결과를 빠르게 동료와 공유할 수 있다
- 자가 테스트 코드, 지속적 통합, 리팩터링이라는 세 기법은 서로 강력한 상승효과를 발휘한다
- 리팩터링과 YAGNI는 서로 긍정적인 영향을 준다. 리팩터링이 YAGNI의 토대인 동시에, YAGNI로 인해 리팩터링을 더욱 쉽게 할 수 있다

### 2.8 리팩터링과 성능

- ‘직관적인 설계 vs 성능’은 중요한 주제다
- 리팩터링하면 소프트웨어가 느려질 수 있는 건 사실이다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다
- 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다
- 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다

  - 먼저 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다
  - 그런 다음 전체를 고르게 최적화할 떄와 마찬가지 방법으로 그 부분들을 개선한다
  - 각 단계마다 컴파일과 테스트를 거치고 프로파일러를 다시 실행해본다
  - 성능이 개선되지 않았다면 수정 내용을 되돌린다
