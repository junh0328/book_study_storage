# 책 소개

**리팩터링, 마틴 파울러**

<img width="400" src="./img.jpg" alt="리팩터링">

## 목차

- [1. 리팩터링 첫 번째 예시](#1-리팩터링-첫-번째-예시)
- [2. 리팩터링 원칙](#2-리팩터링-원칙)
- [3. 코드에서 나는 악취](#3-코드에서-나는-악취)

## 1. 리팩터링 첫 번째 예시

p.26 예시 프로그램을 본 수감

설계가 나쁜 시스템은 수정하기 어렵다. 원하는 동작을 수행하도록 하기위해 수정해야 할 부분을 찾고, 기존 코드와 잘 맞물려 작동하게 할 방법을 강구하기가 어렵기 때문이다. 무엇을 수정할지 찾기 어렵다면 실수를 저질러서 버그가 생길 가능성도 높아진다.

수백 줄짜리 코드를 수정할 때면 먼저 프로그램의 작동 방식을 더 쉽게 파악할 수 있도록 코드를 여러 함수와 프로그램 요소로 재구성한다. 프로그램의 구조가 빈약하다면 대체로 구조부터 바로잡은 뒤에 기능을 수정하는 편이 작업하기가 훨씬 수월하다.

**프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.**

## 2. 리팩터링 원칙

### 2.1 리팩터링정의

- **소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법**
- 명사 - 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
- 동사 - 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다
- 지금껏 수많은 사람이 코드를 정리하는 작업을 모두 ‘리팩터링’이라고 표현하고 있는데, 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다
- 누군가 “리팩터링하다가 코드가 깨져서 며칠이나 고생했다”라고 한다면, 십중팔구 리팩터링한 것이 아니다
- 한 번에 바꿀 수 있는 작업을 수많은 단계로 잘게 나눠서 작업하는 모습을 처음 접하면 리팩터링하는 것이 오히려 비효율적이라고 생각하기 쉽다. 하지만 이렇게 잘게 나눔으로써 오히려 작업을 더 빨리 처리할 수 있다
- 무엇보다 디버깅하는 데 시간을 뺏기지 않기 때문이다
- 리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다. 사용자의 관점에서는 달라지는 점이 없어야 한다
- 리팩터링은 성능 최적화와 비슷하다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다. 단지 목적이 다를 뿐이다. 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 반면 성능 최적화는 오로지 속도 개선에만 신경 쓴다. 그래서 목표 성능에 반드시 도달해야 한다면 코드는 다루기에 더 어렵게 바뀔 수도 있음을 각오해야 한다

### 2.2 두 개의 모자

- 소프트웨어를 개발할 때 목적이 ‘기능 추가’냐, 아니면 ‘리팩터링’이냐를 명확히 구분해 작업한다
- 켄트 벡은 이를 두 개의 모자에 비유했다.
- 기능을 추가할 때는 ‘기능 추가’모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다
- 리팩터링할 때는 ‘리팩터링’ 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다

### 2.3 리팩토링하는 이유

1. 소프트웨어 설계가 좋아진다

   - 리팩터링하지 않으면 소프트웨어 내부 설계(아키텍처)가 썩기 쉽다
   - 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. 그렇다면 코드만 봐서는 설계를 파악하기 어려워진다
   - 코드 구조가 무너지기 시작하면 악효과가 누적된다
   - 같은 일을 하더라도 설계까 나쁘면 코드가 길어지기 십상이다
   - 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있으며, 이는 바람직한 설계의 핵심이다

2. 소프트웨어를 이해하기 쉬워진다

   - 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야 한다
   - 프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일이다
   - 리팩터링은 코드가 더 잘 읽히게 도와준다
   - 단지 다른 사람을 배려하기 위해서가 아니다. 사실 그 다른 사람이 바로 나 자신일 때가 많다
   - 기억할 필요가 있는 것은 최대한 코드에 담으려고 한다(코드 자체만 보고 파악할 수 있도록 만드는 것이 제일 좋다)

3. 버그를 쉽게 찾을 수 있따

   - 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다
   - 리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다

4. 프로그래밍 속도를 높일 수 있다

   - 한 시스템을 오래 개발 중인 개발자들과 얘기하다 보면 초기에는 진척이 빨랐지만 현재는 새 기능을 하나 추가하는데 훨씬 오래 걸린다는 말을 많이 한다
   - 새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다는 것이다
   - 설령 프로그램 요구사항이 바뀌더라도 설계를 지속해서 개선할 수 있다
   - 그래서 빠른 개발이라는 숭고한 목표를 달성하려면 리팩터링이 반드시 필요하다

### 2.4 언제 리팩토링 해야 하나?

1. 프로젝트 시작단계

   - 좋은 디자인 패턴으로 코드를 깔끔하게 작성
   - 기능 구현을 위한 코드를 작성
   - 테스트 코드를 작성 (테스트 코드를 동작하게 하기 위한 리팩토링)
   - **3의 법칙: 비슷한 일을 세 번쨰 하게 되면 리팩토링한다**
   - 코드를 이해하기 쉽게 만들기 > 좋은 문서화
   - 기능을 쉽게 추가하게 만들기 > 재사용성, 모듈성을 높일 수 있음

2. 프로젝트 유지보수 단계

   - 버그름 검증할 수 있는 테스트 코드
   - 코드를 이해하기 쉽게, 변경하기 쉽게 변경 (리팩토링)

3. 오래된(레거시) 프로젝트

   - (버그 수정 및 기능추가시에만) 수정이 필요한 모듈/코드 한정적으로 테스트 추가
   - 리팩토링을 통해 코드 수정 또는 기능을 추가
   - 때로는 새로운 코드를 작성하는 것이 빠를 수 있으므로 우선순위에 따라 전략을 다르게 가져가야 한다

### 2.5 리팩토링 시 고려할 문제

- “무결점 클린코드, 완벽한 설계는 존재하지 않는다”를 인정해야 한다
- 상황에 맞게 좋은 디자인 패턴으로 코드를 깔끔하게 작성하면 된다
- 먼저 기능 구현을 위한 코드를 작성한 이후 테스트 코드를 작성하며 리팩토링을 해나간다.

### 2.6 리팩터링, 아키텍처, 애그니

- 애**그니**: **Y**ou **A**in’t **G**onna **N**eed **I**t
- 당장 필요하지 않는 기능에 집착해서 코드를 지나치게 복잡하게 만들 필요가 없다
- 사용하지 않는 기능을 우선적으로 만들 필요가 없다
- 지나치게 미래지향적인 코드를 작성할 필요가 없다

### 2.7 리팩터링과 소프트웨어 개발 프로세스

- 자가 테스트 코드와 리팩터링을 묶어서 테스트 주도 개발(TDD)이라 한다
- 리팩터링의 첫 번째 토대는 자가 테스트 코드다
- 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할 수 있어야 한다
- 지속적 통합을 적용하면 팀원 각자가 수행한 리팩터링 결과를 빠르게 동료와 공유할 수 있다
- 자가 테스트 코드, 지속적 통합, 리팩터링이라는 세 기법은 서로 강력한 상승효과를 발휘한다
- 리팩터링과 YAGNI는 서로 긍정적인 영향을 준다. 리팩터링이 YAGNI의 토대인 동시에, YAGNI로 인해 리팩터링을 더욱 쉽게 할 수 있다

### 2.8 리팩터링과 성능

- ‘직관적인 설계 vs 성능’은 중요한 주제다
- 리팩터링하면 소프트웨어가 느려질 수 있는 건 사실이다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다
- 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다
- 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다

  - 먼저 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다
  - 그런 다음 전체를 고르게 최적화할 떄와 마찬가지 방법으로 그 부분들을 개선한다
  - 각 단계마다 컴파일과 테스트를 거치고 프로파일러를 다시 실행해본다
  - 성능이 개선되지 않았다면 수정 내용을 되돌린다

## 3. 코드에서 나는 악취

- 이제 리팩터링이 어떻게 작동하는지 감이 왔을 것이다. 하지만 ‘적용 방법’을 아는 것과 ‘제때 적용’할 줄 아는 것은 다르다
- 리팩터링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지 않게 중요하다
- 리팩터링을 ‘언제’ 해야 하는지에 대해서는 명확하게 정립된 규칙이 없다
- 이번 장에서 리팩터링할 ‘시점’을 설명하는데 ‘냄새’라는 표현을 사용했다
- 하지만 리팩터링을 언제 멈춰야 하는지를 판단하는 정확한 기준을 제시하지는 않을 것이다. 숙련된 사람의 직관만큼 정확한 기준은 없기 때문이다

### 3.1 기이한 이름

- 코드를 명료하게 표현하는 데 가장 중요한 요소 하나는 바로 ‘이름’이다
- 그래서 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름 지어야 한다
- 이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다. 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다
- 그래서 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다

- **함수 선언 바꾸기**
- **변수 이름 바꾸기**
- **필드 이름 바꾸기**

### 3.2 중복 코드

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다

- **함수 추출하기**
- **문장 슬라이드하기**
- **메서드 올리기**

### 3.3 긴 함수

- 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐다. 얼핏 훑으면 연산하는 부분이 하나도 없어 보인다. 코드가 끝없이 위임하는 방식으로 작성되어 있기 때문이다
- 간접 호출의 효과, 즉 **코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다**
- 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다
- 적극적으로 함수를 쪼개야 한다. 함수 이름은 동장 방식이 아닌 **‘의도’**가 드러나게 짓는다
- 원래 코드보다 길어지더라도 함수로 뽑는다. ‘무엇을 하는지’를 코드가 잘 설명해주지 못할 수록 함수로 만드는 게 유리하다

- 함수 추출하기
- 임시 변수를 질의 함수로 바꾸기
- 매개변수 객체 만들기
- 객체 통째로 넘기기
- 함수를 명령으로 바꾸기
- 조건문 분해하기
- 함수 추출하기
- 조건부 로직을 다형성으로 바꾸기
- 반복문 쪼개기

### 3.4 긴 매개변수 목록

- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다

- 매개변수를 질의 함수로 바꾸기
- 객체 통째로 넘기기
- 매개변수 객체 만들기
- 플래그 인수 제거하기
- 여러 함수를 클래스로 묶기

### 3.5 전역 데이터

- 전역 데이터를 주의해야 한다는 말은 우리가 소프트웨어 개발을 시작한 초창기부터 귀가 따갑게 들었다. 우리가 겪을 수 있는 악취 중 가장 지독한 축에 속한다

- 변수 캡슐화하기

### 3.6 가변 데이터

- 변경하려는 값에 해당하는 복사본을 만들어서 반환하기

- 변수 캡슐화하기
- 변수 쪼개기
- 문장 슬라이드하기
- 함수 추출하기
- 질의 함수와 변경 함수 분리하기
- 세터 제거하기
- 파생 변수를 질의 함수로 바꾸기
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
- 참조를 값으로 바꾸기

### 3.7 뒤엉킨 변경

- 코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정할 수 있기를 바란다
- 이렇게 할 수 없다면 뒤엉킨 변경과 산탄총 수술 중하나가 풍긴다
- 뒤엉킨 변경은 단일 책임 원칙(Single Responsibility Principle) 이 제대로 지켜지지 않을 때 나타난다. 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다
- 지원해야 할 데이터베이스가 추가될 때마다 함수 세 개를 바꿔야 한다면 ㅁ뒤엉킨 변경이 발생했다는 뜻이다

- 단계 쪼개기
- 함수 옮기기
- 함수 추출하기
- 클래스 추출하기

### 3.8 산탄총 수술

- 이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다
- 변경할 부분이 코드 전반에 퍼져있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다

- 함수 옮기기
- 필드 옮기기
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
- 단계 쪼개기
- 함수 인라인하기
- 클래스 인라인하기

### 3.9 기능 편애

- 프로그램을 모듈화할 때는 코드를 여러 영역**(스코프)**으로 나눈 뒤 영역**(스코프)** 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 **(스코프)**사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력한다
- 기능 편애는 **흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더많을 때 풍기는 냄새다**
- 실행 과정에서 외부 객체의 게터 메서드 대여섯 개를 호출하는 함수가 기능 편애 함수에 해당한다

- 함수 옮기기
- 함수 추출하기

### 3.10 데이터 뭉치

- 데이터 항목들은 어린아이 같은 면이 있다. 어울려 노는 걸 좋아한다
- 데이터 항목 서너 개가 여러 곳에서 항상 함께 뭉쳐다니는 모습을 목격할 수 있다
- 객체를 통째로 넘겨 매개변수의 개수를 줄일 수 있다

- 클래스 추출하기
- 매개변수 객체 만들기
- 객체 통째로 넘기기

### 3.11 기본형 집착

- 프로그래머 중에서는 자신에게 주어진 문제에 딱 맞는 기초 타입(화폐, 좌표, 구간 등)을 직접 정의하기 꺼리는 사람이 많다. 그래서 숫자형으로 계산하거나, 단위를 무시하고 처리하는 코드를 수없이 봤다
- 전화 번호를 단순히 문자 집합으로만 표현하기에는 아쉬움이 많다. 최소한 사용자에게 보여줄 때는 일관된 형식으로 출력해주는 기능이라도 갖춰야 한다

- 기본형을 객체로 바꾸기
- 타입 코드를 서브클래스로 바꾸기
- 조건부 로직을 다형성으로 바꾸기
- 클래스 추출하기
- 매개변수 객체 만들기

### 3.12 반복되는 switch문

- 이 책으 초판에는 “switch문”이란 냄새를 소개하기도 했는데, 사람들이 다형성을 이용하도록 전환시키는 데 도움이 되었기 때문이다
- 단순히 switch문을 썼다고 해서 자동으로 검토 대상은 되지 않는 세상이 되었다
- 그러니 이제는 똑같은 조건부 로직(switch/case문이나 길게 나열된 if/else문)이 여러 곳에서 반복해 등장하는 코드에 집중해보자

- 조건부 로직을 다형성으로 바꾸기

### 3.13 반복문

- 반복문을 파이프라인으로 바꾸기

### 3.14 성의 없는 요소

- 우리는 코드의 구조를 잡을 때 프로그램 요소(프로그래밍 언어가 제공하는 함수, 클래스, 인터페이스 등 코드 구조를 잡는 데 활용되는 요소)를 이용하는 것을 좋아한다. 그래야 그 구조를 변형하거나 재활용할 기회가 생기고, 혹은 단순히 더 의미 있는 이름을 가졌기 때문이다
- 하지만 이런 구조는 나중에 본문을 더 채우거나 다른 메서드를 추가할 생각이었지만, 어떠한 사정으로 인해 그렇게 하지 못한 결과일 수 있다. 혹은 원래는 풍성했던 클래스가 리팩터링을 거치면서 역할이 줄어들었을 수 있다

- 함수 인라인하기
- 클래스 인라인하기
- 계층 합치기

### 3.15 추측성 일반화

- 추측성 일반화는 **‘나중에 필요할 거야’라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리를 로직으로 작성해둔 코드에서 풍기는 냄새**이다
- 미랠를 대비해 작성한 부분을 실제로 사용하게 되면 다행이지만, 그렇지 않는다면 쓸데없는 낭비일 뿐이다

- 계층 합치기
- 함수 인라인하기
- 클래스 인라인하기
- 함수 선언 바꾸기

### 3.16 임시 필드

### 3.17 메시지 체인

### 3.18 중개자

- 객체의 대표적인 기능 하나로, 외부로부터 세부사항을 숨겨주는 캡슐화가 있다
- 캡슐화하는 과정에서는 위임이 자주 활용된다
- 하지만 지나치면 문제가 된다. 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 어떤가? 이럴 때는 **중개자 제거하기**를 활용하여 실제로 일을 하는 객체와 직접 소통하게 하자

### 3.19 내부자 거래

### 3.20 거대한 클래스

### 3.21 서로 다른 인터페이스의 대안 클래스들

### 3.22 데이터 클래스

### 3.23 상속 포기

### 3.24 주석

- 주석을 달면 안 된다고 말하려는 건 아니니 걱정하지 말자
- 주석은 악취가 아닌 향기를 입힌다. 문제는 주석을 탈취제처럼 사용하는 데 있다
- 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다
- 주석이 많으면 이 장에서 소개한 온갖 악취를 풍기는 코드가 나오기 쉽다
- 특정 코드 블록이 하는 일에 주석을 남기고 싶다면 **함수 추출하기**를 적용해 본다
- 이미 추출되어 있는 함수임에도 여전히 설명이 필요하다면 **함수 선언 바꾸기**로 함수 이름을 바꿔본다
- 주석을 남겨야 겠다는 생각이 들면, 가장 먼저 주석이 필요없는 코드로 리팩터링해본다
